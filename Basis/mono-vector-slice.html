<!-- HTML/mono-vector-slice.html -->

<!-- COPYRIGHT (c) 2000 Bell Labs, Lucent Technologies. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The MONO_VECTOR_SLICE signature</TITLE>
<META NAME=generator CONTENT="ML-Doc::html-gen">
</HEAD>
<BODY BGCOLOR="#FFFFFF"><A NAME="top"></A>
<H1 align=CENTER>The Standard ML Basis Library</H1>
<HR>


<H2><A NAME="section:0"></A>The <CODE>MONO_VECTOR_SLICE</CODE> signature</H2>
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature</B>&nbsp;<A NAME="MONO_VECTOR_SLICE:SIG:SPEC"></A><CODE>MONO_VECTOR_SLICE</CODE><BR>
<B>structure</B>&nbsp;<A NAME="Word8VectorSlice:STR:SPEC"></A><CODE>Word8VectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;Word8Vector.vector<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;Word8.word<BR>
<B>structure</B>&nbsp;<A NAME="CharVectorSlice:STR:SPEC"></A><CODE>CharVectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;slice&nbsp;=&nbsp;<A HREF="substring.html#SIG:SUBSTRING.substring:TY:SPEC">Substring.substring</A><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;<A HREF="string.html#SIG:STRING.string:TY:SPEC">String.string</A><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;char<BR>
<B>structure</B>&nbsp;<A NAME="WideCharVectorSlice:STR:SPEC"></A><CODE>WideCharVectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;slice&nbsp;=&nbsp;<A HREF="substring.html#SIG:SUBSTRING.substring:TY:SPEC">WideSubstring.substring</A><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;<A HREF="string.html#SIG:STRING.string:TY:SPEC">WideString.string</A><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;<A HREF="char.html#SIG:CHAR.char:TY:SPEC">WideChar.char</A><BR>
<B>structure</B>&nbsp;<A NAME="BoolVectorSlice:STR:SPEC"></A><CODE>BoolVectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;BoolVector.vector<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;bool<BR>
<B>structure</B>&nbsp;<A NAME="IntVectorSlice:STR:SPEC"></A><CODE>IntVectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;IntVector.vector<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;int<BR>
<B>structure</B>&nbsp;<A NAME="WordVectorSlice:STR:SPEC"></A><CODE>WordVectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;WordVector.vector<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;word<BR>
<B>structure</B>&nbsp;<A NAME="RealVectorSlice:STR:SPEC"></A><CODE>RealVectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;RealVector.vector<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;real<BR>
<B>structure</B>&nbsp;<A NAME="LargeIntVectorSlice:STR:SPEC"></A><CODE>LargeIntVectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;LargeIntVector.vector<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;LargeInt.int<BR>
<B>structure</B>&nbsp;<A NAME="LargeWordVectorSlice:STR:SPEC"></A><CODE>LargeWordVectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;LargeWordVector.vector<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;LargeWord.word<BR>
<B>structure</B>&nbsp;<A NAME="LargeRealVectorSlice:STR:SPEC"></A><CODE>LargeRealVectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;LargeRealVector.vector<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;LargeReal.real<BR>
<B>structure</B>&nbsp;<A NAME="Int{N}VectorSlice:STR:SPEC"></A><CODE>Int<I>&lt;N&gt;</I>VectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;<A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">Int{N}.int</A><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;<A HREF="mono-vector.html#SIG:MONO_VECTOR.vector:TY:SPEC">Int{N}Vector.vector</A><BR>
<B>structure</B>&nbsp;<A NAME="Word{N}VectorSlice:STR:SPEC"></A><CODE>Word<I>&lt;N&gt;</I>VectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;<A HREF="word.html#SIG:WORD.word:TY:SPEC">Word{N}.word</A><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;<A HREF="mono-vector.html#SIG:MONO_VECTOR.vector:TY:SPEC">Word{N}Vector.vector</A><BR>
<B>structure</B>&nbsp;<A NAME="Real{N}VectorSlice:STR:SPEC"></A><CODE>Real<I>&lt;N&gt;</I>VectorSlice</CODE><B> :> </B>MONO_VECTOR_SLICE&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;<A HREF="real.html#SIG:REAL.real:TY:SPEC">Real{N}.real</A><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;<A HREF="mono-vector.html#SIG:MONO_VECTOR.vector:TY:SPEC">Real{N}Vector.vector</A><BR>
</CODE>
</BLOCKQUOTE>
<P>
The <CODE>MONO_VECTOR_SLICE</CODE> signature provides an abstraction of subarrays for monomorphic immutable arrays or vectors. A <CODE>slice</CODE> value can be viewed as a triple  <CODE>(<VAR>v</VAR>, <VAR>i</VAR>, <VAR>n</VAR>)</CODE>, where <VAR>v</VAR> is the underlying vector, <VAR>i</VAR> is the starting index, and <VAR>n</VAR> is the length of the subarray, with the constraint that  0 &lt;= <VAR>i</VAR> &lt;= <VAR>i</VAR> + <VAR>n</VAR> &lt;= |<VAR>v</VAR>|, where |<VAR>v</VAR>| is the length of the vector <VAR>v</VAR>. Slices provide a convenient notation for specifying and operating on a contiguous subset of elements in a vector. 
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>type</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.elem:TY:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.elem:TY">elem</A><BR>
<B>type</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.vector:TY:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.vector:TY">vector</A><BR>
<B>type</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.slice:TY:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.slice:TY">slice</A><BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.length:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.length:VAL">length</A>&nbsp;<B>:</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;int<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.sub:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.sub:VAL">sub</A>&nbsp;<B>:</B>&nbsp;slice&nbsp;<B>*</B>&nbsp;int&nbsp;<B>-&gt;</B>&nbsp;elem<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.full:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.full:VAL">full</A>&nbsp;<B>:</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;slice<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.slice:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.slice:VAL">slice</A>&nbsp;<B>:</B>&nbsp;vector&nbsp;<B>*</B>&nbsp;int&nbsp;<B>*</B>&nbsp;int&nbsp;option&nbsp;<B>-&gt;</B>&nbsp;slice<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.subslice:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.subslice:VAL">subslice</A>&nbsp;<B>:</B>&nbsp;slice&nbsp;<B>*</B>&nbsp;int&nbsp;<B>*</B>&nbsp;int&nbsp;option&nbsp;<B>-&gt;</B>&nbsp;slice<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.base:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.base:VAL">base</A>&nbsp;<B>:</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>*</B>&nbsp;int&nbsp;<B>*</B>&nbsp;int<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.vector:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.vector:VAL">vector</A>&nbsp;<B>:</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;vector<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.concat:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.concat:VAL">concat</A>&nbsp;<B>:</B>&nbsp;slice&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;vector<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.isEmpty:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.isEmpty:VAL">isEmpty</A>&nbsp;<B>:</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.getItem:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.getItem:VAL">getItem</A>&nbsp;<B>:</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;(elem&nbsp;<B>*</B>&nbsp;slice)&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.appi:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.appi:VAL">appi</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>-&gt;</B>&nbsp;unit)&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.app:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.app:VAL">app</A>&nbsp;&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>-&gt;</B>&nbsp;unit)&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.mapi:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.mapi:VAL">mapi</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>-&gt;</B>&nbsp;elem)&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;vector<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.map:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.map:VAL">map</A>&nbsp;&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>-&gt;</B>&nbsp;elem)&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;vector<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.foldli:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.foldli:VAL">foldli</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>)&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I><BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.foldr:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.foldr:VAL">foldr</A>&nbsp;&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>)&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I><BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.foldl:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.foldl:VAL">foldl</A>&nbsp;&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>)&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I><BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.foldri:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.foldri:VAL">foldri</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>)&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I><BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.findi:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.findi:VAL">findi</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>-&gt;</B>&nbsp;bool)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem)&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.find:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.find:VAL">find</A>&nbsp;&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>-&gt;</B>&nbsp;bool)&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;elem&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.exists:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.exists:VAL">exists</A>&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>-&gt;</B>&nbsp;bool)&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.all:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.all:VAL">all</A>&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>-&gt;</B>&nbsp;bool)&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR_SLICE.collate:VAL:SPEC" HREF="#SIG:MONO_VECTOR_SLICE.collate:VAL">collate</A>&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>-&gt;</B>&nbsp;order)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;slice&nbsp;<B>*</B>&nbsp;slice&nbsp;<B>-&gt;</B>&nbsp;order</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="SIG:MONO_VECTOR_SLICE.vector:TY"></A><CODE><B>type</B>&nbsp;vector</CODE>
<DD>
      The underlying monomorphic vector type. We denote the length of a vector <VAR>vec</VAR> of type <CODE><A HREF="mono-vector-slice.html#SIG:MONO_VECTOR_SLICE.vector:TY:SPEC">vector</A></CODE> by |<VAR>vec</VAR>|. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.length:VAL"></A>
<DT> <CODE>length <VAR>sl</VAR> </CODE>
<DD>
returns |<VAR>sl</VAR>|, the length (<I>i.e.</I>, number of elements) of the slice. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.sub:VAL"></A>
<DT> <CODE>sub (<VAR>sl</VAR>, <VAR>i</VAR>) </CODE>
<DD>
returns the <VAR>i</VAR><SUP>(th)</SUP> element of the slice <VAR>sl</VAR>. If <VAR>i</VAR> &lt; 0 or |<VAR>sl</VAR>| &lt;= <VAR>i</VAR>, then the <CODE><A HREF="general.html#SIG:GENERAL.Subscript:EXN:SPEC">Subscript</A></CODE> exception is raised. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.full:VAL"></A>
<DT> <CODE>full <VAR>vec</VAR> </CODE>
<DD>
creates a slice representing the entire vector <VAR>vec</VAR>. It is equivalent to 
<PRE>
<A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.slice:VAL:SPEC">slice</A>(<VAR>vec</VAR>, 0, <A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A>)
</PRE>
 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.slice:VAL"></A>
<DT> <CODE>slice (<VAR>vec</VAR>, <VAR>i</VAR>, <VAR>sz</VAR>) </CODE>
<DD>
creates a slice based on the vector <VAR>vec</VAR> starting at index <VAR>i</VAR> of the vector <VAR>vec</VAR>. If <VAR>sz</VAR> is <CODE><A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A></CODE>, the slice includes all of the elements to the end of the vector, <I>i.e.</I>, <VAR>vec</VAR>[<VAR>i</VAR>..|<VAR>vec</VAR>|-1]. This raises <CODE><A HREF="general.html#SIG:GENERAL.Subscript:EXN:SPEC">Subscript</A></CODE> if <CODE><VAR>i</VAR> &lt; 0</CODE> or |<VAR>vec</VAR>| &lt; <VAR>i</VAR>. If <VAR>sz</VAR> is <CODE><CODE><A HREF="option.html#SIG:OPTION.option:TY:SPEC">SOME</A></CODE>(<VAR>j</VAR>)</CODE>, the slice has length <VAR>j</VAR>, that is, it corresponds to <CODE><VAR>vec</VAR>[<VAR>i</VAR>..<VAR>i</VAR>+<VAR>j</VAR>-1]</CODE>. It raises <CODE><A HREF="general.html#SIG:GENERAL.Subscript:EXN:SPEC">Subscript</A></CODE> if <VAR>i</VAR> &lt; 0 or <VAR>j</VAR> &lt; 0 or |<VAR>vec</VAR>| &lt; <VAR>i</VAR> + <VAR>j</VAR>. Note that, if defined, <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.slice:VAL:SPEC">slice</A></CODE> returns an empty slice when <VAR>i</VAR> = |<VAR>vec</VAR>|. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.subslice:VAL"></A>
<DT> <CODE>subslice (<VAR>sl</VAR>, <VAR>i</VAR>, <VAR>sz</VAR>) </CODE>
<DD>
creates a slice based on the given slice <VAR>sl</VAR> starting at index <VAR>i</VAR> of <VAR>sl</VAR>. If <VAR>sz</VAR> is <CODE><A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A></CODE>, the slice includes all of the elements to the end of the slice, <I>i.e.</I>, <VAR>sl</VAR>[<VAR>i</VAR>..|<VAR>sl</VAR>|-1]. This raises <CODE><A HREF="general.html#SIG:GENERAL.Subscript:EXN:SPEC">Subscript</A></CODE> if <CODE><VAR>i</VAR> &lt; 0</CODE> or |<VAR>sl</VAR>| &lt; <VAR>i</VAR>. If <VAR>sz</VAR> is <CODE><CODE><A HREF="option.html#SIG:OPTION.option:TY:SPEC">SOME</A></CODE>(<VAR>j</VAR>)</CODE>, the slice has length <VAR>j</VAR>, that is, it corresponds to <CODE><VAR>sl</VAR>[<VAR>i</VAR>..<VAR>i</VAR>+<VAR>j</VAR>-1]</CODE>. It raises <CODE><A HREF="general.html#SIG:GENERAL.Subscript:EXN:SPEC">Subscript</A></CODE> if <VAR>i</VAR> &lt; 0 or <VAR>j</VAR> &lt; 0 or |<VAR>sl</VAR>| &lt; <VAR>i</VAR> + <VAR>j</VAR>. Note that, if defined, <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.slice:VAL:SPEC">slice</A></CODE> returns an empty slice when <VAR>i</VAR> = |<VAR>sl</VAR>|. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.base:VAL"></A>
<DT> <CODE>base <VAR>sl</VAR> </CODE>
<DD>
returns a triple <CODE>(<VAR>vec</VAR>, <VAR>i</VAR>, <VAR>n</VAR>)</CODE> representing the concrete representation of the slice. <VAR>vec</VAR> is the underlying vector, <VAR>i</VAR> is the starting index, and <VAR>n</VAR> is the length of the slice. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.vector:VAL"></A>
<DT> <CODE>vector <VAR>sl</VAR> </CODE>
<DD>
generates a vector from the slice <VAR>sl</VAR>. Specifically, if <VAR>vec</VAR> is the resulting vector, we have |<VAR>vec</VAR>| = |<VAR>sl</VAR>| and, for 0 &lt;= <VAR>i</VAR> &lt; |<VAR>sl</VAR>|, element <VAR>i</VAR> of <VAR>vec</VAR> is <CODE>sub (<VAR>sl</VAR>, i)</CODE>. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.concat:VAL"></A>
<DT> <CODE>concat <VAR>l</VAR> </CODE>
<DD>
is the concatenation of all the vectors in <VAR>l</VAR>. This raises <CODE><A HREF="general.html#SIG:GENERAL.Size:EXN:SPEC">Size</A></CODE> if the sum of all the lengths is greater than the maximum length allowed by vectors of type <CODE><A HREF="mono-vector-slice.html#SIG:MONO_VECTOR_SLICE.vector:TY:SPEC">vector</A></CODE>. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.isEmpty:VAL"></A>
<DT> <CODE>isEmpty <VAR>sl</VAR> </CODE>
<DD>
returns <CODE>true</CODE> if <VAR>sl</VAR> has length 0. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.getItem:VAL"></A>
<DT> <CODE>getItem <VAR>sl</VAR> </CODE>
<DD>
returns the first item in <VAR>sl</VAR> and the rest of the slice, or <CODE><A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A></CODE> if <VAR>sl</VAR> is empty. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.appi:VAL"></A>
<DT> <CODE>appi <VAR>f</VAR> <VAR>sl</VAR> </CODE>
<DT> <CODE>          app <VAR>f</VAR> <VAR>sl</VAR> </CODE>
<DD>
These apply the function <VAR>f</VAR> to the elements of a slice in left to right order (<I>i.e.</I>, increasing indices). The more general <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.appi:VAL:SPEC">appi</A></CODE> function supplies <VAR>f</VAR> with the index of the corresponding element in the slice. The expression <CODE>app <VAR>f</VAR> <VAR>sl</VAR></CODE> is equivalent to <CODE>appi (<VAR>f</VAR> o #2) <VAR>sl</VAR></CODE>. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.mapi:VAL"></A>
<DT> <CODE>mapi <VAR>f</VAR> <VAR>sl</VAR> </CODE>
<DT> <CODE>          map <VAR>f</VAR> <VAR>sl</VAR> </CODE>
<DD>
These functions generate new vectors by mapping the function <VAR>f</VAR> from left to right over the argument slice. The more general <CODE><A HREF="vector-slice.html#SIG:VECTOR_SLICE.mapi:VAL:SPEC">mapi</A></CODE> function supplies both the element and the element's index in the slice to the function <VAR>f</VAR>. The latter expression is equivalent to: 
<PRE>
      mapi (<VAR>f</VAR> o #2) <VAR>sl</VAR>
      
</PRE>
 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.foldli:VAL"></A>
<DT> <CODE>foldli <VAR>f</VAR> <VAR>init</VAR> <VAR>sl</VAR> </CODE>
<DT> <CODE>          foldr <VAR>f</VAR> <VAR>init</VAR> <VAR>sl</VAR> </CODE>
<DT> <CODE>          foldl <VAR>f</VAR> <VAR>init</VAR> <VAR>sl</VAR> </CODE>
<DT> <CODE>          foldri <VAR>f</VAR> <VAR>init</VAR> <VAR>sl</VAR> </CODE>
<DD>
These fold the function <VAR>f</VAR> over all the elements of a vector slice, using  the value <VAR>init</VAR> as the initial value.  The functions <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.foldli:VAL:SPEC">foldli</A></CODE> and <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.foldl:VAL:SPEC">foldl</A></CODE> apply the function <VAR>f</VAR>  from left to right (increasing indices), while the functions  <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.foldri:VAL:SPEC">foldri</A></CODE> and <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.foldr:VAL:SPEC">foldr</A></CODE> work from right to left (decreasing indices).  The more general functions <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.foldli:VAL:SPEC">foldli</A></CODE> and <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.foldri:VAL:SPEC">foldri</A></CODE> supply <VAR>f</VAR> with the index of the corresponding element in the slice. 
<P>
      Refer to the <CODE><A HREF="mono-array.html#MONO_ARRAY:SIG:SPEC">MONO_ARRAY</A></CODE> manual pages for reference implementations of the indexed versions.  
<P>
 The expression <CODE>foldl <VAR>f</VAR> <VAR>init</VAR> <VAR>sl</VAR></CODE>  is equivalent to:  
<PRE>
foldli (fn (_, <VAR>a</VAR>, <VAR>x</VAR>) =&gt; <VAR>f</VAR>(<VAR>a</VAR>, <VAR>x</VAR>)) <VAR>init</VAR> <VAR>sl</VAR>
</PRE>
 The analogous equivalence holds for <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.foldri:VAL:SPEC">foldri</A></CODE> and <CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.foldr:VAL:SPEC">foldr</A></CODE>. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.findi:VAL"></A>
<DT> <CODE>findi <VAR>f</VAR> <VAR>sl</VAR> </CODE>
<DT> <CODE>          find <VAR>f</VAR> <VAR>sl</VAR> </CODE>
<DD>
These apply <VAR>f</VAR> to each element of the slice <VAR>sl</VAR>, from left to right (<I>i.e.</I>, increasing indices), until a <CODE>true</CODE> value is returned. If this occurs, the functions return the element; otherwise, they return <CODE><A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A></CODE>. The more general version <CODE><A HREF="mono-vector-slice.html#SIG:MONO_VECTOR_SLICE.findi:VAL:SPEC">findi</A></CODE> also supplies <VAR>f</VAR> with the index of the element in the slice and, upon finding an entry satisfying the predicate, returns that index with the element. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.exists:VAL"></A>
<DT> <CODE>exists <VAR>f</VAR> <VAR>sl</VAR> </CODE>
<DD>
applies <VAR>f</VAR> to each element <VAR>x</VAR> of the slice <VAR>sl</VAR>, from left to right (<I>i.e.</I>, increasing indices), until <CODE><VAR>f</VAR> <VAR>x</VAR></CODE> evaluates to <CODE>true</CODE>; it returns <CODE>true</CODE> if such an <VAR>x</VAR> exists and <CODE>false</CODE> otherwise. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.all:VAL"></A>
<DT> <CODE>all <VAR>f</VAR> <VAR>sl</VAR> </CODE>
<DD>
applies <VAR>f</VAR> to each element <VAR>x</VAR> of the slice <VAR>sl</VAR>, from left to right (<I>i.e.</I>, increasing indices), until <CODE><VAR>f</VAR> <VAR>x</VAR></CODE> evaluates to <CODE>false</CODE>; it returns <CODE>false</CODE> if such an <VAR>x</VAR> exists and <CODE>true</CODE> otherwise. It is equivalent to  <CODE><CODE><A HREF="bool.html#SIG:BOOL.not:VAL:SPEC">not</A></CODE>(<CODE><A HREF="mono-array-slice.html#SIG:MONO_ARRAY_SLICE.exists:VAL:SPEC">exists</A></CODE> (<CODE><A HREF="bool.html#SIG:BOOL.not:VAL:SPEC">not</A></CODE> o <VAR>f</VAR>) <VAR>sl</VAR>))</CODE>. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR_SLICE.collate:VAL"></A>
<DT> <CODE>collate <VAR>f</VAR> (<VAR>sl</VAR>, <VAR>sl2</VAR>) </CODE>
<DD>
performs lexicographic comparison of the two slices using the given ordering <VAR>f</VAR> on elements. 
<BR>
<BR>

</DL>
<H4>See Also</H4>
<BLOCKQUOTE>
<CODE><A HREF="mono-array.html#MONO_ARRAY:SIG:SPEC">MONO_ARRAY</A></CODE>, <CODE><A HREF="mono-array-slice.html#MONO_ARRAY_SLICE:SIG:SPEC">MONO_ARRAY_SLICE</A></CODE>, <CODE><A HREF="mono-vector.html#MONO_VECTOR:SIG:SPEC">MONO_VECTOR</A></CODE>, <CODE><A HREF="vector-slice.html#VectorSlice:STR:SPEC">VectorSlice</A></CODE>
</BLOCKQUOTE>
<H4>Discussion</H4>
<P>
If an implementation provides a structure matching <CODE><A HREF="mono-vector-slice.html#MONO_VECTOR_SLICE:SIG:SPEC">MONO_VECTOR_SLICE</A></CODE> for some element type <CODE>ty</CODE>, it must provide the corresponding monomorphic structure matching <CODE><A HREF="mono-vector.html#MONO_VECTOR:SIG:SPEC">MONO_VECTOR</A></CODE> with the vector types in the two structures identified.


<HR>
<CENTER>
<B>[ <A HREF="#top">Top</A>
   | <A HREF="manpages.html">Parent</A>
   | <A HREF="toc.html">Contents</A>
   | <A HREF="index-all.html">Index</A>
   | <A HREF="index.html">Root</A>
   ]</B>
</CENTER>
<P>
<I>Generated April 12, 2004</I><BR>
<I>Last Modified June 20, 2000</I><BR>
<I>Comments to <A HREF="http://www.cs.uchicago.edu/people/jhr">John Reppy.</A></I><BR>

<HR>
<P>

This document may be distributed freely over the internet as long as the
copyright notice and license terms below are prominently displayed within
every machine-readable copy.  

<P>

<TABLE ALIGN=CENTER WIDTH="80%" BORDER="2" CELLPADDING="5">
<TR>
<TD>
<P>

Copyright &copy; 2004 AT&amp;T and Lucent Technologies.
All rights reserved.

<P>

Permission is granted for internet users to make one paper copy for their
own personal use.  Further hardcopy reproduction is strictly prohibited. 
Permission to distribute the HTML document electronically on any medium
other than the internet must be requested from the copyright holders by
contacting the editors.
Printed versions of the SML Basis Manual are available from Cambridge
University Press.
To order, please visit
<A HREF="http://www.cup.org">www.cup.org</A> (North America) or
<A HREF="http://www.cup.cam.ac.uk">www.cup.cam.ac.uk</A> (outside North America).<BR>

</TABLE>
<P>

<HR>
</BODY></HTML>
