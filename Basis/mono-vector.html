<!-- HTML/mono-vector.html -->

<!-- COPYRIGHT (c) 1997 Bell Labs, Lucent Technologies. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The MONO_VECTOR signature</TITLE>
<META NAME=generator CONTENT="ML-Doc::html-gen">
</HEAD>
<BODY BGCOLOR="#FFFFFF"><A NAME="top"></A>
<H1 align=CENTER>The Standard ML Basis Library</H1>
<HR>


<H2><A NAME="section:0"></A>The <CODE>MONO_VECTOR</CODE> signature</H2>
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature</B>&nbsp;<A NAME="MONO_VECTOR:SIG:SPEC"></A><CODE>MONO_VECTOR</CODE><BR>
<B>structure</B>&nbsp;<A NAME="Word8Vector:STR:SPEC"></A><CODE>Word8Vector</CODE><B> :> </B>MONO_VECTOR<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;Word8.word<BR>
<B>structure</B>&nbsp;<A NAME="CharVector:STR:SPEC"></A><CODE>CharVector</CODE><B> :> </B>MONO_VECTOR<BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;<A HREF="string.html#SIG:STRING.string:TY:SPEC">String.string</A><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;char<BR>
<B>structure</B>&nbsp;<A NAME="WideCharVector:STR:SPEC"></A><CODE>WideCharVector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;vector&nbsp;=&nbsp;<A HREF="string.html#SIG:STRING.string:TY:SPEC">WideString.string</A><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;<A HREF="char.html#SIG:CHAR.char:TY:SPEC">WideChar.char</A><BR>
<B>structure</B>&nbsp;<A NAME="BoolVector:STR:SPEC"></A><CODE>BoolVector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;bool<BR>
<B>structure</B>&nbsp;<A NAME="IntVector:STR:SPEC"></A><CODE>IntVector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;int<BR>
<B>structure</B>&nbsp;<A NAME="WordVector:STR:SPEC"></A><CODE>WordVector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;word<BR>
<B>structure</B>&nbsp;<A NAME="RealVector:STR:SPEC"></A><CODE>RealVector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;real<BR>
<B>structure</B>&nbsp;<A NAME="LargeIntVector:STR:SPEC"></A><CODE>LargeIntVector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;LargeInt.int<BR>
<B>structure</B>&nbsp;<A NAME="LargeWordVector:STR:SPEC"></A><CODE>LargeWordVector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;LargeWord.word<BR>
<B>structure</B>&nbsp;<A NAME="LargeRealVector:STR:SPEC"></A><CODE>LargeRealVector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;LargeReal.real<BR>
<B>structure</B>&nbsp;<A NAME="Int{N}Vector:STR:SPEC"></A><CODE>Int<I>&lt;N&gt;</I>Vector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;<A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">Int{N}.int</A><BR>
<B>structure</B>&nbsp;<A NAME="Word{N}Vector:STR:SPEC"></A><CODE>Word<I>&lt;N&gt;</I>Vector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;<A HREF="word.html#SIG:WORD.word:TY:SPEC">Word{N}.word</A><BR>
<B>structure</B>&nbsp;<A NAME="Real{N}Vector:STR:SPEC"></A><CODE>Real<I>&lt;N&gt;</I>Vector</CODE><B> :> </B>MONO_VECTOR&nbsp;&nbsp;<FONT COLOR="#FF0000"><CODE><I>(* OPTIONAL *)</I></CODE></FONT><BR>
&nbsp;&nbsp;<B>where</B>&nbsp;<B>type</B>&nbsp;elem&nbsp;=&nbsp;<A HREF="real.html#SIG:REAL.real:TY:SPEC">Real{N}.real</A><BR>
</CODE>
</BLOCKQUOTE>
<P>
The <CODE>MONO_VECTOR</CODE> signature is a generic interface to monomorphic vectors, immutable sequences with constant-time access. Monomorphic vectors allow more compact representations than the analogous polymorphic vectors over the same element type. 
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>type</B>&nbsp;<A NAME="SIG:MONO_VECTOR.vector:TY:SPEC" HREF="#SIG:MONO_VECTOR.vector:TY">vector</A><BR>
<B>type</B>&nbsp;<A NAME="SIG:MONO_VECTOR.elem:TY:SPEC" HREF="#SIG:MONO_VECTOR.elem:TY">elem</A><BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.maxLen:VAL:SPEC" HREF="#SIG:MONO_VECTOR.maxLen:VAL">maxLen</A>&nbsp;<B>:</B>&nbsp;int<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.fromList:VAL:SPEC" HREF="#SIG:MONO_VECTOR.fromList:VAL">fromList</A>&nbsp;<B>:</B>&nbsp;elem&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;vector<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.tabulate:VAL:SPEC" HREF="#SIG:MONO_VECTOR.tabulate:VAL">tabulate</A>&nbsp;<B>:</B>&nbsp;int&nbsp;<B>*</B>&nbsp;(int&nbsp;<B>-&gt;</B>&nbsp;elem)&nbsp;<B>-&gt;</B>&nbsp;vector<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.length:VAL:SPEC" HREF="#SIG:MONO_VECTOR.length:VAL">length</A>&nbsp;<B>:</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;int<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.sub:VAL:SPEC" HREF="#SIG:MONO_VECTOR.sub:VAL">sub</A>&nbsp;<B>:</B>&nbsp;vector&nbsp;<B>*</B>&nbsp;int&nbsp;<B>-&gt;</B>&nbsp;elem<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.update:VAL:SPEC" HREF="#SIG:MONO_VECTOR.update:VAL">update</A>&nbsp;<B>:</B>&nbsp;vector&nbsp;<B>*</B>&nbsp;int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>-&gt;</B>&nbsp;vector<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.concat:VAL:SPEC" HREF="#SIG:MONO_VECTOR.concat:VAL">concat</A>&nbsp;<B>:</B>&nbsp;vector&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;vector<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.appi:VAL:SPEC" HREF="#SIG:MONO_VECTOR.appi:VAL">appi</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>-&gt;</B>&nbsp;unit)&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.app:VAL:SPEC" HREF="#SIG:MONO_VECTOR.app:VAL">app</A>&nbsp;&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>-&gt;</B>&nbsp;unit)&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.mapi:VAL:SPEC" HREF="#SIG:MONO_VECTOR.mapi:VAL">mapi</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>-&gt;</B>&nbsp;elem)&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;vector<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.map:VAL:SPEC" HREF="#SIG:MONO_VECTOR.map:VAL">map</A>&nbsp;&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>-&gt;</B>&nbsp;elem)&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;vector<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.foldli:VAL:SPEC" HREF="#SIG:MONO_VECTOR.foldli:VAL">foldli</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>)&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I><BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.foldri:VAL:SPEC" HREF="#SIG:MONO_VECTOR.foldri:VAL">foldri</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>)&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I><BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.foldl:VAL:SPEC" HREF="#SIG:MONO_VECTOR.foldl:VAL">foldl</A>&nbsp;&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>)&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I><BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.foldr:VAL:SPEC" HREF="#SIG:MONO_VECTOR.foldr:VAL">foldr</A>&nbsp;&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>)&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I><BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.findi:VAL:SPEC" HREF="#SIG:MONO_VECTOR.findi:VAL">findi</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>-&gt;</B>&nbsp;bool)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;elem)&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.find:VAL:SPEC" HREF="#SIG:MONO_VECTOR.find:VAL">find</A>&nbsp;&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>-&gt;</B>&nbsp;bool)&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;elem&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.exists:VAL:SPEC" HREF="#SIG:MONO_VECTOR.exists:VAL">exists</A>&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>-&gt;</B>&nbsp;bool)&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.all:VAL:SPEC" HREF="#SIG:MONO_VECTOR.all:VAL">all</A>&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>-&gt;</B>&nbsp;bool)&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="SIG:MONO_VECTOR.collate:VAL:SPEC" HREF="#SIG:MONO_VECTOR.collate:VAL">collate</A>&nbsp;<B>:</B>&nbsp;(elem&nbsp;<B>*</B>&nbsp;elem&nbsp;<B>-&gt;</B>&nbsp;order)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;vector&nbsp;<B>*</B>&nbsp;vector&nbsp;<B>-&gt;</B>&nbsp;order</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="SIG:MONO_VECTOR.maxLen:VAL"></A><CODE><B>val</B>&nbsp;maxLen&nbsp;<B>:</B>&nbsp;int</CODE>
<DD>
          The maximum length of vectors supported by this implementation.  Attempts to create larger vectors will result in the <CODE><A HREF="general.html#SIG:GENERAL.Size:EXN:SPEC">Size</A></CODE>  exception being raised. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.fromList:VAL"></A>
<DT> <CODE>fromList <VAR>l</VAR> </CODE>
<DD>
creates a new vector from <VAR>l</VAR>, whose length is <CODE>length <VAR>l</VAR></CODE> and with the <VAR>i</VAR><SUP>(th)</SUP> element of <VAR>l</VAR> used as the <VAR>i</VAR><SUP>(th)</SUP> element of the vector. If the length of the  list is greater than <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.maxLen:VAL:SPEC">maxLen</A></CODE>, then the <CODE><A HREF="general.html#SIG:GENERAL.Size:EXN:SPEC">Size</A></CODE>  exception is raised. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.tabulate:VAL"></A>
<DT> <CODE>tabulate (<VAR>n</VAR>, <VAR>f</VAR>) </CODE>
<DD>
creates a vector of <VAR>n</VAR> elements, where the elements are  defined in order of increasing index by applying <VAR>f</VAR> to  the element's index.  This is equivalent to the expression:  
<PRE>
fromList (List.tabulate (<VAR>n</VAR>, <VAR>f</VAR>))
</PRE>
  If <VAR>n</VAR> &lt; 0 or  <CODE>maxLen</CODE> &lt; <VAR>n</VAR>, then the <CODE><A HREF="general.html#SIG:GENERAL.Size:EXN:SPEC">Size</A></CODE>  exception is raised. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.length:VAL"></A>
<DT> <CODE>length <VAR>vec</VAR> </CODE>
<DD>
returns |<VAR>vec</VAR>|, the length (<I>i.e.</I>, the number of elements) of the vector <VAR>vec</VAR>. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.sub:VAL"></A>
<DT> <CODE>sub (<VAR>vec</VAR>, <VAR>i</VAR>) </CODE>
<DD>
returns the <VAR>i</VAR><SUP>(th)</SUP> element of the vector <VAR>vec</VAR>.  If <VAR>i</VAR> &lt; 0 or  |<VAR>vec</VAR>| &lt;= <VAR>i</VAR>, then  the <CODE><A HREF="general.html#SIG:GENERAL.Subscript:EXN:SPEC">Subscript</A></CODE> exception is raised. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.update:VAL"></A>
<DT> <CODE>update (<VAR>vec</VAR>, <VAR>i</VAR>, <VAR>x</VAR>) </CODE>
<DD>
returns a new vector, identical to <VAR>vec</VAR>, except the <VAR>i</VAR><SUP>(th)</SUP> element of <VAR>vec</VAR> is set to <VAR>x</VAR>.  If <VAR>i</VAR> &lt; 0 or  |<VAR>vec</VAR>| &lt;= <VAR>i</VAR>, then  the <CODE><A HREF="general.html#SIG:GENERAL.Subscript:EXN:SPEC">Subscript</A></CODE> exception is raised. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.concat:VAL"></A>
<DT> <CODE>concat <VAR>l</VAR> </CODE>
<DD>
returns the vector that is the concatenation of the vectors in the  list <VAR>l</VAR>.  If the total length of these vectors exceeds <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.maxLen:VAL:SPEC">maxLen</A></CODE>,  then the <CODE><A HREF="general.html#SIG:GENERAL.Size:EXN:SPEC">Size</A></CODE> exception is raised. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.appi:VAL"></A>
<DT> <CODE>appi <VAR>f</VAR> <VAR>vec</VAR> </CODE>
<DT> <CODE>          app <VAR>f</VAR> <VAR>vec</VAR> </CODE>
<DD>
These apply the function <VAR>f</VAR> to the elements of a vector in  left to right order (<I>i.e.</I>, increasing indices).  The more general <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.appi:VAL:SPEC">appi</A></CODE> function  supplies both the element and the element's index to the  function <VAR>f</VAR>.  The expression <CODE>app <VAR>f</VAR> <VAR>vec</VAR></CODE>  is equivalent to:  
<PRE>
      appi (<VAR>f</VAR> o #2) <VAR>vec</VAR>
      
</PRE>
 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.mapi:VAL"></A>
<DT> <CODE>mapi <VAR>f</VAR> <VAR>vec</VAR> </CODE>
<DT> <CODE>          map <VAR>f</VAR> <VAR>vec</VAR> </CODE>
<DD>
These functions produce new vectors by mapping the function <VAR>f</VAR> from left to right over the argument vector.  The more general <CODE><A HREF="vector.html#SIG:VECTOR.mapi:VAL:SPEC">mapi</A></CODE> function  supplies both the element and the element's index to the  function <VAR>f</VAR>.  The expression <CODE>mapi <VAR>f</VAR> <VAR>vec</VAR></CODE>  is equivalent to:  
<PRE>
      fromList (List.map f (foldri (fn (i,a,l) =&gt; (i,a)::l) [] vec))
      
</PRE>
  The expression <CODE>map <VAR>f</VAR> <VAR>vec</VAR></CODE>  is equivalent to:  
<PRE>
      mapi (<VAR>f</VAR> o #2) <VAR>vec</VAR>
      
</PRE>
 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.foldli:VAL"></A>
<DT> <CODE>foldli <VAR>f</VAR> <VAR>init</VAR> <VAR>vec</VAR>  </CODE>
<DT> <CODE>            foldri <VAR>f</VAR> <VAR>init</VAR> <VAR>vec</VAR>  </CODE>
<DT> <CODE>            foldl <VAR>f</VAR> <VAR>init</VAR> <VAR>vec</VAR>  </CODE>
<DT> <CODE>            foldr <VAR>f</VAR> <VAR>init</VAR> <VAR>vec</VAR> </CODE>
<DD>
These fold the function <VAR>f</VAR> over all the elements of a vector, using  the value <VAR>init</VAR> as the initial value.  The functions <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.foldli:VAL:SPEC">foldli</A></CODE> and <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.foldl:VAL:SPEC">foldl</A></CODE> apply the function <VAR>f</VAR>  from left to right (increasing indices), while the functions  <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.foldri:VAL:SPEC">foldri</A></CODE> and <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.foldr:VAL:SPEC">foldr</A></CODE> work from right to left (decreasing indices).  The more general functions <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.foldli:VAL:SPEC">foldli</A></CODE> and <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.foldri:VAL:SPEC">foldri</A></CODE> supply both the  element and the element's index to the function <VAR>f</VAR>. 
<P>
      Refer to the <CODE><A HREF="mono-array.html#MONO_ARRAY:SIG:SPEC">MONO_ARRAY</A></CODE> manual pages for reference implementations of the indexed versions. 
<P>
 The expression <CODE>foldl <VAR>f</VAR></CODE>  is equivalent to:  
<PRE>
      foldli (fn (_, <VAR>a</VAR>, <VAR>x</VAR>) =&gt; <VAR>f</VAR>(<VAR>a</VAR>, <VAR>x</VAR>))
      
</PRE>
 A similar relation holds between <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.foldr:VAL:SPEC">foldr</A></CODE> and <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.foldri:VAL:SPEC">foldri</A></CODE>. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.findi:VAL"></A>
<DT> <CODE>findi <VAR>f</VAR> <VAR>vec</VAR> </CODE>
<DT> <CODE>          find <VAR>f</VAR> <VAR>vec</VAR> </CODE>
<DD>
These apply <VAR>f</VAR> to each element of the vector <VAR>vec</VAR>, from left to right (<I>i.e.</I>, increasing indices), until a <CODE>true</CODE> value is returned. If this occurs, the functions return the element; otherwise, they return <CODE><A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A></CODE>. The more general version <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.findi:VAL:SPEC">findi</A></CODE> also supplies <VAR>f</VAR> with the vector index of the element and, upon finding an entry satisfying the predicate, returns that index with the element. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.exists:VAL"></A>
<DT> <CODE>exists <VAR>f</VAR> <VAR>vec</VAR> </CODE>
<DD>
applies <VAR>f</VAR> to each element <VAR>x</VAR> of the vector <VAR>vec</VAR>, from left to right (<I>i.e.</I>, increasing indices), until <CODE><VAR>f</VAR> <VAR>x</VAR></CODE> evaluates to <CODE>true</CODE>; it returns <CODE>true</CODE> if such an <VAR>x</VAR> exists and <CODE>false</CODE> otherwise. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.all:VAL"></A>
<DT> <CODE>all <VAR>f</VAR> <VAR>vec</VAR> </CODE>
<DD>
applies <VAR>f</VAR> to each element <VAR>x</VAR> of the vector <VAR>vec</VAR>, from left to right (<I>i.e.</I>, increasing indices), until <CODE><VAR>f</VAR> <VAR>x</VAR></CODE> evaluates to <CODE>false</CODE>; it returns <CODE>false</CODE> if such an <VAR>x</VAR> exists and <CODE>true</CODE> otherwise. It is equivalent to <CODE><CODE><A HREF="bool.html#SIG:BOOL.not:VAL:SPEC">not</A></CODE>(<CODE><A HREF="vector.html#SIG:VECTOR.exists:VAL:SPEC">exists</A></CODE> (<CODE><A HREF="bool.html#SIG:BOOL.not:VAL:SPEC">not</A></CODE> o <VAR>f</VAR>
) <VAR>vec</VAR>))</CODE>. 
<BR>
<BR>

<DT> <A NAME="SIG:MONO_VECTOR.collate:VAL"></A>
<DT> <CODE>collate <VAR>f</VAR> (<VAR>v1</VAR>, <VAR>v2</VAR>) </CODE>
<DD>
performs lexicographic comparison of the two vectors using the given ordering <VAR>f</VAR> on elements. 
<BR>
<BR>

</DL>
<H4>See Also</H4>
<BLOCKQUOTE>
<CODE><A HREF="mono-array.html#MONO_ARRAY:SIG:SPEC">MONO_ARRAY</A></CODE>, <CODE><A HREF="mono-array-slice.html#MONO_ARRAY_SLICE:SIG:SPEC">MONO_ARRAY_SLICE</A></CODE>, <CODE><A HREF="mono-vector-slice.html#MONO_VECTOR_SLICE:SIG:SPEC">MONO_VECTOR_SLICE</A></CODE>, <CODE><A HREF="vector.html#Vector:STR:SPEC">Vector</A></CODE>
</BLOCKQUOTE>
<H4>Discussion</H4>
<P>
  The type <CODE><A HREF="string.html#SIG:STRING.string:TY:SPEC">String.string</A></CODE> is identical to <CODE>CharVector.vector</CODE>.


<HR>
<CENTER>
<B>[ <A HREF="#top">Top</A>
   | <A HREF="manpages.html">Parent</A>
   | <A HREF="toc.html">Contents</A>
   | <A HREF="index-all.html">Index</A>
   | <A HREF="index.html">Root</A>
   ]</B>
</CENTER>
<P>
<I>Generated April 12, 2004</I><BR>
<I>Last Modified May 26, 2000</I><BR>
<I>Comments to <A HREF="http://www.cs.uchicago.edu/people/jhr">John Reppy.</A></I><BR>

<HR>
<P>

This document may be distributed freely over the internet as long as the
copyright notice and license terms below are prominently displayed within
every machine-readable copy.  

<P>

<TABLE ALIGN=CENTER WIDTH="80%" BORDER="2" CELLPADDING="5">
<TR>
<TD>
<P>

Copyright &copy; 2004 AT&amp;T and Lucent Technologies.
All rights reserved.

<P>

Permission is granted for internet users to make one paper copy for their
own personal use.  Further hardcopy reproduction is strictly prohibited. 
Permission to distribute the HTML document electronically on any medium
other than the internet must be requested from the copyright holders by
contacting the editors.
Printed versions of the SML Basis Manual are available from Cambridge
University Press.
To order, please visit
<A HREF="http://www.cup.org">www.cup.org</A> (North America) or
<A HREF="http://www.cup.cam.ac.uk">www.cup.cam.ac.uk</A> (outside North America).<BR>

</TABLE>
<P>

<HR>
</BODY></HTML>
